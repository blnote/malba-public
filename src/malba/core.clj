;; Copyright 2023 blnote.
;; This file is part of MALBA.

(ns malba.core
  "main namespace. initializes GUI. load database configuration file.
   events from GUI are dispatched through event-dispatch which 
   sets up worker agent that sequentially consumes events (event-consume) that have  dispatched 
   by the UI (event-dispatch)."
  (:gen-class)
  (:require [clojure.string :as string]
            [malba.cache :as c]
            [malba.database :as db]
            [malba.file-io :as f]
            [malba.gephi :as gephi]
            [malba.gui :as gui]
            [malba.logger :as l]
            [malba.algorithms.malba-params :as malba-params]
            [malba.algorithms.proto-algo-params :as algo-params]
            [malba.algorithms.proto-algo :as a]
            [malba.utils :as u]))


;;GLOBALS
(def version "0.5.1")
(def db-conf-file "database.edn")
(def exit-on-close true) ;true for production
(reset! l/DEBUG false) ;toggle debugging messages

(defn init-worker
  "init worker agent for time-consuming tasks initiated by user" []
  (let [err-handler (fn [_ e] (l/error (string/join [(ex-message e) (ex-cause e)])))]
    (doto (agent {})
      (set-error-handler! err-handler)
      (set-error-mode! :continue)
      (set-validator! (fn [state] (map? state))))))

(defn event-consume
  "main work horse. this function is send to the worker agent
   together with the event generated by the user. it is then called by the agent
   and the events are consumed"
  [state event params]
  (l/event-to-status event :start)
  (doto (condp = event
          "read-db-config" (if-let [conf (f/load-config db-conf-file)]
                             (do 
                               (l/text (format "Database config loaded from %s." db-conf-file))
                               (gui/invoke :set-db-info conf)
                               (assoc state :db-config conf))
                             (do 
                               (l/error (format "Database config not readable from %s!\n Database mode will not work." db-conf-file))
                               (assoc state :db-config nil)))
          "save-session" (doto state (u/save-session! version params))
          "load-session" (let [state (u/load-session params)]
                           (l/text (format ">>> Loaded session from %s." (.getName ^java.io.File params)))
                           (doto state (u/show-results! true) u/update-ui!))
          "load-seed" (let [seed-file (.getName ^java.io.File params)
                            seed (f/load-seed params)]
                        (when (empty? seed)
                          (throw (Error. (format "No seeds found in %s." seed-file))))
                        (l/text (format ">>> Loaded %d seeds from %s." (count seed) seed-file))
                        (-> state
                            (assoc :seed seed)
                            (assoc :seed-file seed-file)
                            (doto u/update-ui!)))
          "load-network" (let [network-file (.getName ^java.io.File params)
                               C (c/from-file params)]
                           (l/text (format ">>> Loaded network from %s." network-file))
                           (-> state (assoc :cache C) (doto u/update-ui!)))
          "db-connect" (if-let  [db (get-in state [:cache :db])]
                         (assoc-in state [:cache :db]
                                   (-> (merge db (gui/invoke :get-db-info))
                                       db/close!
                                       db/connect)) ;reconnect
                         (let [C (-> (get state :db-config)
                                     (merge (gui/invoke :get-db-info)) 
                                     db/connect
                                     c/init ;initalize cache with db-connection 
                                     )]
                           (-> state (assoc :cache C))))
          "clear-cache" (if (and (state :cache) ;if cache and db info exists
                                 (get-in state [:cache :db]))
                          (assoc state :cache (c/init (get-in state [:cache :db])))
                          state)
          "algo-step" (u/without-algo-buttons
                       #(let [pa (gui/invoke :get-params)]
                          (if (u/algo-changed? state pa) (u/init-algo state)
                              (let [algo (-> (state :algo) (a/set-params pa) a/step)
                                    error (a/error algo)]
                                (cond
                                  (= error :sql-query-too-large)
                                  (throw (Error. "SQL-query too large. (> max-sql-query-size)"))
                                  (= error :subgraph-too-large)
                                  (throw (Error. "Subgraph too large!"))
                                  (a/interrupted? algo) (do (l/text ">>> Step interrupted.") state)
                                  (a/terminated? algo)
                                  (do (l/text ">>> Terminated: no new elements added in cycle!")
                                      (doto (assoc state :algo algo) u/show-results!))
                                  :else (doto (assoc state :algo algo) u/show-results!))))))
          "algo-run" (u/without-algo-buttons
                      #(let [pa (gui/invoke :get-params)
                             state (if (u/algo-changed? state pa) (u/init-algo state) state)
                             algo (-> (state :algo) (a/set-params pa) a/run)
                             error (a/error algo)]
                         (cond
                           (= error :sql-query-too-large)
                           (throw (Exception. "SQL-query too large. (> max-sql-query-size)"))
                           (= error :subgraph-too-large)
                           (throw (Error. "Subgraph too large!"))
                           (a/interrupted? algo)
                           (do (l/text (format ">>> Interrupted after %d cycles!" (a/steps algo)))
                               (doto (assoc state :algo algo) u/show-results!))
                           (a/terminated? algo)
                           (do (l/text (format ">>> Terminated after %d cycles!" (a/steps algo)))
                               (doto (assoc state :algo algo) u/show-results!))
                           :else (throw (Exception. "Unknown algorithm state.")))))
          "algo-reset" (do (gephi/view-reset) (u/init-algo state))
          "algo-search" (u/without-algo-buttons
                         #(let [pa (gui/invoke :get-params)
                                state (if (u/algo-changed? state pa) (u/init-algo state) state)]
                            (l/text ">>> Starting parameter search...")
                            (let [{:keys [interrupted params size]}
                                  (-> (state :algo) (a/set-params pa) a/search)]
                              (if interrupted
                                (l/text "\nParameter search interrupted!")
                                (l/text "\nParameter search completed!"))
                              (if (nil? params)
                                (l/text "No valid parameters found.")
                                (do
                                  (l/text (format "Max: %s subgraph: %s" (algo-params/to-string params) size))
                                  (l/text "Parameters updated, run algorithm to view subgraph.")
                                  (doto (update state :algo a/set-params params)
                                    (u/update-ui!)))))
                            state))
          "view-reset" (do (gephi/view-reset) (gui/invoke :reset-preview) state)
          "view-surrounding" (do (gephi/view-surrounding params) (gui/invoke :refresh-preview) state)
          "view-neighbors" (do (gephi/view-neighbors params) (gui/invoke :refresh-preview) state)
          "hovered" (do (when (> 1000 (- (System/currentTimeMillis) (params :time)))
                          (let [node-info (gephi/hovered (params :event))]
                            (gui/invoke :show-details (u/generate-detail-str node-info))
                            (gui/invoke :refresh-preview)))
                        state)
          "copy-to-clipboard" (let [node-info (gephi/hovered params)]
                                (u/copy-to-clipboard (u/generate-detail-str node-info))
                                state)
          "layout" (do (gephi/layout-graph params) (gui/invoke :reset-preview) state)
          "export" (do (gephi/export params) state)
          "window-close" (when (state :cache)
                           (db/close! (get-in state [:cache :db])))
          (throw (IllegalAccessError. (format "%s not implemented..." event))))
    ((fn [_] (l/event-to-status event :stop)))))


(defn event-dispatch
  "called from event-callbacks in ui thread. events are send to a worker agent and thus will be queued and consumed sequentially due to concurrency with gephi."
  ([worker ^String event] (event-dispatch worker event {}))
  ([worker ^String event params] 
   (l/debug (format "Dispatching event %s with parameters %s" event (str params)))
   (if (= event "algo-stop")
     (do (reset! (get-in @worker [:algo :interrupted]) true)
         (l/status "Stopping algorithm..."))
     (do
       (send worker event-consume event params)
       ;try algorithm initialization automatically after the following events:
       (when (contains? #{"db-connect" "load-seed" "load-network"} event)
         (send worker u/init-algo))))
   nil))

(defn -main [& _]
  (let [worker (init-worker)]
    (gui/init {:version version
               :exit_on_close exit-on-close
               :preview (gephi/init) ;setup render target for preview
               :event-dispatch (partial event-dispatch worker)})
    (event-dispatch worker "read-db-config")
    ;send default algorithm parameters to UI 
    (gui/invoke :set-params (-> (malba-params/->Params) (algo-params/init) (algo-params/get-vars)))
    worker))

(comment
  ;Start program with 
  (-main)
  ;for testing useful:
  (reset! l/DEBUG true)
  (def worker (-main)))